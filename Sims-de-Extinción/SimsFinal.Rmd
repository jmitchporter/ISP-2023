---
title: "SimsMod"
author: "Mitch Porter"
date: "2023-11-19"
output: html_document
---

```{r setup, include=TRUE}
library(multiweb)
library(igraph)
library(tidyverse)
library(NetIndices)

# load data
ESnodes <- read.csv("./ESBurdwoodSpeciesList.csv")
ESlinks <- read.csv("./ESInteractionList_Burdwood.csv")
importance_seq <- read.csv("IndirectAll.csv", header=T)
```

```{r}
# species only subset
SPPnodes <- subset(ESnodes, ESnodes$vertextype < 30) # exclude ES from node list 
SPPlinks <- subset(ESlinks, ESlinks$edgetype == 0) # subset interactions to remove all ES links
SPPnet <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes) # as graph

# create sequence vectors
sym_diff <- function(a,b) unique(c(setdiff(a,b), setdiff(b,a))) #custom right outer join function

#least and most connected
SPPnet <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes)
degree <- degree(SPPnet, loops = TRUE) #determine degrees for connection
SPPnodes$degree <- degree
least_conn_seqSPP <- SPPnodes[order(SPPnodes$degree),] #least connected
least_conn_seqSPP <- as.vector(least_conn_seqSPP[,1])
most_conn_seqSPP <- SPPnodes[order(SPPnodes$degree, decreasing = TRUE), ] #most connected
most_conn_seqSPP <- as.vector(most_conn_seqSPP[,1])

#support subgroup
all <- as.vector(SPPnodes[,1])
provider_seqSPP <- subset(ESlinks, ESlinks$edgetype > 0) #isolate providers
provider_seqSPP <- as.vector(provider_seqSPP[,1])
provider_seqSPP <- unique(provider_seqSPP)
support_seqSPP <- sym_diff(provider_seqSPP, all) #isolate supporters
support_seqSPP <- unique(support_seqSPP)
ran_support_seqSPP <- sample(support_seqSPP, length(support_seqSPP), replace = FALSE) #randomize supporters
ran_support_seqSPP <- c(ran_support_seqSPP, provider_seqSPP) # add providers to network
importance_support_seqSPP <- as.vector(importance_seq[,2]) #load pageranks
importance_support_seqSPP <- sym_diff(importance_support_seqSPP, provider_seqSPP) #sort to only support species
importance_support_seqSPP <- c(importance_support_seqSPP, provider_seqSPP) #add providers to end of net

#providers subgroup
ran_provider_seqSPP <- sample(provider_seqSPP, length(provider_seqSPP), replace = FALSE) #randomize providers
ran_provider_seqSPP <- c(ran_provider_seqSPP, support_seqSPP) #add supporters to end

#order according to seq
SPPnodes1 <- SPPnodes[match(least_conn_seqSPP, SPPnodes$Species), ]
SPPnodes2 <- SPPnodes[match(most_conn_seqSPP, SPPnodes$Species), ]
SPPnodes3 <- SPPnodes[match(importance_support_seqSPP, SPPnodes$Species), ]
SPPnodes4 <- SPPnodes[match(ran_support_seqSPP, SPPnodes$Species), ]
SPPnodes5 <- SPPnodes[match(ran_provider_seqSPP, SPPnodes$Species), ]

SPPnet1 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes1) #as graph
SPPmat1 <- as_adjacency_matrix(SPPnet1, sparse = FALSE, attr = NULL) #as matrix
SPPnet1 <- as.data.frame(SPPmat1) #as df
SPPnet2 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes2) #as graph
SPPmat2 <- as_adjacency_matrix(SPPnet2, sparse = FALSE, attr = NULL) #as matrix
SPPnet2 <- as.data.frame(SPPmat2) #as df
SPPnet3 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes3) #as graph
SPPmat3 <- as_adjacency_matrix(SPPnet3, sparse = FALSE, attr = NULL) #as matrix
SPPnet3 <- as.data.frame(SPPmat3) #as df
SPPnet4 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes4) #as graph
SPPmat4 <- as_adjacency_matrix(SPPnet4, sparse = FALSE, attr = NULL) #as matrix
SPPnet4 <- as.data.frame(SPPmat4) #as df
SPPnet5 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes5) #as graph
SPPmat5 <- as_adjacency_matrix(SPPnet5, sparse = FALSE, attr = NULL) #as matrix
SPPnet5 <- as.data.frame(SPPmat5) #as df

#rotate active network as needed
#redSPP <- SPPnet1
#redSPP <- SPPnet2
#redSPP <- SPPnet3
#redSPP <- SPPnet4
redSPP <- SPPnet5

producers <- data.frame(SpeciesID = SPPnodes$Species, InDegree = igraph::degree(SPPnet, mode="in"))
producers <- producers[producers$InDegree==0,]
N <-length(producers)
Net<-list()
S <- length(redSPP)

#thresholdvector
  thresh<- 1/10
  NumPrey <-rep(0,S)
  vectorthresh <- as.data.frame(NumPrey,row.names=names(redSPP))
  #thresh <- 1-thresh
  for (b in 1:S) {
    vectorthresh[b,1] <- sum(redSPP[,b])}
  vectorthresh <- (vectorthresh*thresh)
  vectorthresh <- as.vector(vectorthresh[,1])
  net<-list()
  A <- rbind(redSPP,vectorthresh)
  for (x in 1:S){
    if(length(A)>9 & sum(A)!=0){ #mayor a 9 porque Vane habia puesto un corte del 10%
      B <- A[-1,]
      A <- B[,-1]
      repeat {
        if (length(A) > 1){
          a <- vector("integer",0)
          for (l in 1:length(A)) {
            z <- vector("logical",0)
            for (k in 1:N) {z <- c(z, names(A)[l] == producers[k])}
          if ((sum((A[-(length(A)+1),])[,l]) <= A[(length(A)+1),l]) & !any(z)){
            a <- c(a,l)}}
        if (length(a)>0){
          A <- A[-a,]
          A <- A[,-a]
          } else {
            # m<-A[-(length(A)+1),]
            break}}}
      m<-A[-(length(A)+1),]
      net[[x]] <-m
      }} #de la ext primaria

#data calculations
net_spp<- data.frame()
for (i in 1:length(net)){
  count<-count(net[[i]])
  net_spp <- rbind(net_spp, count)
}

net_spp$pri_ext <- 1:nrow(net_spp)
net_spp$sec_ext <- (((379) - net_spp$pri_ext) - net_spp$n)

#save as needed, as there is no subgroup function that also allows secondary extinctions
#to take place for a species, cutoffs must be checked by hand
#stats_spp1 <- net_spp
#net_spp1 <- net
#stats_spp2 <- net_spp
#net_spp2 <- net
#stats_spp3 <- top_n(net_spp, 86, n)
#net_spp3 <- net1
#stats_spp4 <- top_n(net_spp, 218, n)
#net_spp4 <- net
stats_spp5 <- top_n(net_spp, 91, n)
net_spp5 <- net

#for subgroups (i.e, nets 3, 4, and5 ), it would be better to direct the loop to break 
#when subgroup is no longer present in the net, however, because there are so few sims,
#in this case I am checking each net by hand to see when to cut the extinction net to 
#only the relevant subgroup

```

```{r}
#ES-inclusive subset

#identify ES
ES <- subset(ESnodes, ESnodes$vertextype > 30)
ES <- as.vector(ES[,1])
#ES are placed at the end to decrease the likelihood they will be removed in a primary extinction. 
#not included in an dnr group because they need to be subject to "secondary extinctions"

# create sequence vectors
sym_diff <- function(a,b) unique(c(setdiff(a,b), setdiff(b,a))) #custom right outer join function

#least and most connected
ESnet <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes) #determine degrees for connection
degree <- degree(ESnet, loops = TRUE)
ESnodes$degree <- degree
least_conn_seq <- ESnodes[order(ESnodes$degree),] #least connected
least_conn_seq <- as.vector(least_conn_seq[,1])
least_conn_seq <- sym_diff(ES,least_conn_seq) #place ES at end
least_conn_seq <- c(least_conn_seq, ES)
most_conn_seq <- ESnodes[order(ESnodes$degree, decreasing = TRUE), ] #most connected
most_conn_seq <- as.vector(most_conn_seq[,1])
most_conn_seq <- sym_diff(ES, most_conn_seq) #place ES at end
most_conn_seq <- c(most_conn_seq, ES)

#support species
all <- as.vector(ESnodes[,1])
provider_seq <- subset(ESlinks, ESlinks$edgetype > 0)
provider_seq <- as.vector(provider_seq[,1])
provider_seq <- unique(provider_seq)
support_seq <- sym_diff(provider_seq, all) #isolate supporting species
support_seq <- unique(support_seq)
ran_support_seq <- sample(support_seq, length(support_seq), replace = FALSE) #randomize
ran_support_seq <- c(ran_support_seq, provider_seq) #add non-supporting species to end of web
ran_support_seq <- sym_diff(ES, ran_support_seq) 
ran_support_seq <- c(ran_support_seq, ES) #place ES at end
importance_support_seq <- as.vector(importance_seq[,2]) #load personalized pageranks
importance_support_seq <- c(importance_support_seq, ES)
importance_support_seq <- sym_diff(importance_support_seq, provider_seq) #sort to only support species
importance_support_seq <- c(importance_support_seq, provider_seq) #add non-supporting species to end of web
importance_support_seq <- sym_diff(ES, importance_support_seq)
importance_support_seq <- c(importance_support_seq, ES) #place ES at end

#provider species
provider_seq <- subset(ESlinks, ESlinks$edgetype > 0) #isolate provider species
provider_seq <- as.vector(provider_seq[,1])
provider_seq <- unique(provider_seq)
ran_provider_seq <- sample(provider_seq, length(provider_seq), replace = FALSE) #randomize
ran_provider_seq <- c(ran_provider_seq, support_seq) #add non-provider species to web
ran_provider_seq <- sym_diff(ES, ran_provider_seq)
ran_provider_seq <- c(ran_provider_seq, ES) #place ES at end

#order nodes according to seq
ESnodes1 <- ESnodes[match(least_conn_seq, ESnodes$Species), ]
ESnodes2 <- ESnodes[match(most_conn_seq, ESnodes$Species), ]
ESnodes3 <- ESnodes[match(importance_support_seq, ESnodes$Species), ]
ESnodes4 <- ESnodes[match(ran_support_seq, ESnodes$Species), ]
ESnodes5 <- ESnodes[match(ran_provider_seq, ESnodes$Species), ]

#create network objects for each sequence
ESnet1 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes1) #as graph
ESmat1 <- as_adjacency_matrix(ESnet1, sparse = FALSE, attr = NULL) #as matrix
ESnet1 <- as.data.frame(ESmat1) #as df
ESnet2 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes2) #as graph
ESmat2 <- as_adjacency_matrix(ESnet2, sparse = FALSE, attr = NULL) #as matrix
ESnet2 <- as.data.frame(ESmat2) #as df
ESnet3 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes3) #as graph
ESmat3 <- as_adjacency_matrix(ESnet3, sparse = FALSE, attr = NULL) #as matrix
ESnet3 <- as.data.frame(ESmat3) #as df
ESnet4 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes4) #as graph
ESmat4 <- as_adjacency_matrix(ESnet4, sparse = FALSE, attr = NULL) #as matrix
ESnet4 <- as.data.frame(ESmat4) #as df
ESnet5 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes5) #as graph
ESmat5 <- as_adjacency_matrix(ESnet5, sparse = FALSE, attr = NULL) #as matrix
ESnet5 <- as.data.frame(ESmat5) #as df

#prepare for extinction simulations
#rotate active network as needed
#redES <- ESnet1
#redES <- ESnet2
#redES <- ESnet3
#redES <- ESnet4
redES <- ESnet5

producers <- data.frame(SpeciesID = SPPnodes$Species, InDegree = igraph::degree(SPPnet, mode="in"))
producers <- producers[producers$InDegree==0,]
N <-length(producers)
Net<-list()
S <- length(redES)

  thresh<- 1/10 #can be set to any threshold; this is closest to Keyes
  NumPrey <-rep(0,S)
  vectorthresh <- as.data.frame(NumPrey,row.names=names(redES))
  #thresh <- 1-thresh
  for (b in 1:S) {
    vectorthresh[b,1] <- sum(redES[,b])}
  vectorthresh <- (vectorthresh*thresh)
  vectorthresh <- as.vector(vectorthresh[,1])
  net<-list()
  A <- rbind(redES,vectorthresh)
  for (x in 1:S){
    if(length(A)>9 & sum(A)!=0){ #mayor a 9 porque Vane habia puesto un corte del 10%
      B <- A[-1,]
      A <- B[,-1]
      repeat {
        if (length(A) > 1){
          a <- vector("integer",0)
          for (l in 1:length(A)) {
            z <- vector("logical",0)
            for (k in 1:N) {z <- c(z, names(A)[l] == producers[k])}
          if ((sum((A[-(length(A)+1),])[,l]) <= A[(length(A)+1),l]) & !any(z)){
            a <- c(a,l)}}
        if (length(a)>0){
          A <- A[-a,]
          A <- A[,-a]
          } else {
            # m<-A[-(length(A)+1),]
            break}}}
      m<-A[-(length(A)+1),]
      net[[x]] <-m
      }} #end primary extinction

#data calculations
net_ES<- data.frame()
for (i in 1:length(net)){
  species <- as.data.frame(net[[i]])
  species <- names(species)
  species_diff <- intersect(ES,species)
  ES_lost <- (length(ES)-length(species_diff))
  net_ES <- rbind(net_ES, ES_lost)
}

net_ES$pri_ext <- 1:nrow(net_ES)
num <- count(net_ES)
num <- as.integer(num)
net_ES$n <- num - net_ES$pri_ext #dummy variable to resverse order for cuts

#rotate active network as needed
#stats_ES1 <- net_ES
#net_ES1 <- net
#stats_ES2 <- top_n(net_ES, 84, n)
#net_ES2 <- net
#stats_ES3 <- top_n(net_ES, 86, n)
#net_ES3 <- net
#stats_ES4 <- top_n(net_ES, 206, n)
#net_ES4 <- net
stats_ES5 <- top_n(net_ES, 89, n)
net_ES5 <- net

#for subgroups (i.e, nets 3, 4, and5 ), it would be better to direct the loop to break 
#when subgroup is no longer present in the net, however, because there are so few sims,
#in this case I am checking each net by hand to see when to cut the extinction net to 
#only the relevant subgroup

```