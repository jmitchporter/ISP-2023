---
title: "CordoneExtSimMod"
author: "Mitch Porter"
date: "2023-11-19"
output: html_document
---

```{r setup, include=TRUE}
library(multiweb)
library(igraph)
library(tidyverse)
library(NetIndices)

# load data
ESnodes <- read.csv("./ESBurdwoodSpeciesList.csv")
ESlinks <- read.csv("./ESInteractionList_Burdwood.csv")
importance_seq <- read.csv("IndirectAll.csv", header=T)

```

```{r}
# species only subset
SPPnodes <- subset(ESnodes, ESnodes$vertextype < 30) # exclude ES from node list 
SPPlinks <- subset(ESlinks, ESlinks$edgetype == 0) # subset interactions to remove all ES links
SPPnet <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes) # as graph

#flag nodes not to be removed
#identify primary producers
producers <- data.frame(SpeciesID = SPPnodes$Species, InDegree = igraph::degree(SPPnet, mode="in"))
producers <- producers[producers$InDegree==0,]
    #write.csv(producers, "./producers.csv") #remove consumers with no input vertices by hand
producers <- read.csv("./producers.csv")
producers <- as.vector(producers[,1])
dnr <- producers

# create sequence vectors
sym_diff <- function(a,b) unique(c(setdiff(a,b), setdiff(b,a))) #custom right outer join function

#least and most connected
SPPnet <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes)
degree <- degree(SPPnet, loops = TRUE) #determine degrees for connection
SPPnodes$degree <- degree
least_conn_seqSPP <- SPPnodes[order(SPPnodes$degree),] #least connected
least_conn_seqSPP <- as.vector(least_conn_seqSPP[,1])
least_conn_seqSPP <- sym_diff(dnr,least_conn_seqSPP)
least_conn_seqSPP <- c(least_conn_seqSPP, dnr) #place producers at end
most_conn_seqSPP <- SPPnodes[order(SPPnodes$degree, decreasing = TRUE), ] #most connected
most_conn_seqSPP <- as.vector(most_conn_seqSPP[,1])
most_conn_seqSPP <- sym_diff(dnr, most_conn_seqSPP)
most_conn_seqSPP <- c(most_conn_seqSPP, dnr) #place producers at end

#support subgroup
all <- as.vector(SPPnodes[,1])
provider_seqSPP <- subset(ESlinks, ESlinks$edgetype > 0) #isolate providers
provider_seqSPP <- as.vector(provider_seqSPP[,1])
provider_seqSPP <- unique(provider_seqSPP)
support_seqSPP <- sym_diff(provider_seqSPP, all) #isolate supporters
support_seqSPP <- unique(support_seqSPP)
ran_support_seqSPP <- sample(support_seqSPP, length(support_seqSPP), replace = FALSE) #randomize supporters
ran_support_seqSPP <- c(ran_support_seqSPP, provider_seqSPP) # add providers to network
ran_support_seqSPP <- sym_diff(dnr, ran_support_seqSPP)
ran_support_seqSPP <- c(ran_support_seqSPP, dnr) # place producers at end
importance_support_seqSPP <- as.vector(importance_seq[,2]) #load pageranks
importance_support_seqSPP <- sym_diff(importance_support_seqSPP, provider_seq) #sort to only support species
importance_support_seqSPP <- c(importance_support_seqSPP, provider_seqSPP) #add providers to end of net
importance_support_seqSPP <- sym_diff(dnr, importance_support_seqSPP) 
importance_support_seqSPP <- c(importance_support_seqSPP, dnr) # add producers to end of net

#providers subgroup
ran_provider_seqSPP <- sample(provider_seqSPP, length(provider_seqSPP), replace = FALSE) #randomize providers
ran_provider_seqSPP <- c(ran_provider_seqSPP, support_seqSPP) #add supporters to end
ran_provider_seqSPP <- sym_diff(dnr, ran_provider_seqSPP)
ran_provider_seqSPP <- c(ran_provider_seqSPP, dnr) #add producers to end

#order according to seq
SPPnodes1 <- SPPnodes[match(least_conn_seqSPP, SPPnodes$Species), ]
SPPnodes2 <- SPPnodes[match(most_conn_seqSPP, SPPnodes$Species), ]
SPPnodes3 <- SPPnodes[match(importance_support_seqSPP, SPPnodes$Species), ]
SPPnodes4 <- SPPnodes[match(ran_support_seqSPP, SPPnodes$Species), ]
SPPnodes5 <- SPPnodes[match(ran_provider_seqSPP, SPPnodes$Species), ]

SPPnet1 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes1) #as graph
SPPmat1 <- as_adjacency_matrix(SPPnet1, sparse = FALSE, attr = NULL) #as matrix
SPPnet1 <- as.data.frame(SPPmat1) #as df
SPPnet2 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes2) #as graph
SPPmat2 <- as_adjacency_matrix(SPPnet2, sparse = FALSE, attr = NULL) #as matrix
SPPnet2 <- as.data.frame(SPPmat2) #as df
SPPnet3 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes3) #as graph
SPPmat3 <- as_adjacency_matrix(SPPnet3, sparse = FALSE, attr = NULL) #as matrix
SPPnet3 <- as.data.frame(SPPmat3) #as df
SPPnet4 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes4) #as graph
SPPmat4 <- as_adjacency_matrix(SPPnet4, sparse = FALSE, attr = NULL) #as matrix
SPPnet4 <- as.data.frame(SPPmat4) #as df
SPPnet5 <- graph.data.frame(SPPlinks, directed = T, vertices = SPPnodes5) #as graph
SPPmat5 <- as_adjacency_matrix(SPPnet5, sparse = FALSE, attr = NULL) #as matrix
SPPnet5 <- as.data.frame(SPPmat5) #as df

#rotate active network as needed
#redSPP <- SPPnet1
#redSPP <- SPPnet2
#redSPP <- SPPnet3
#redSPP <- SPPnet4
redSPP <- SPPnet5

N <-length(dnr)
Net<-list()
S <- length(redSPP)

#thresholdvector
for (i in 1:9){
  thresh<- i/10
  NumPrey <-rep(0,S)
  vectorthresh <- as.data.frame(NumPrey,row.names=names(redSPP))
  #thresh <- 1-thresh
  for (b in 1:S) {
    vectorthresh[b,1] <- sum(redSPP[,b])}
  vectorthresh <- (vectorthresh*thresh)
  vectorthresh <- as.vector(vectorthresh[,1])
  net<-list()
  A <- rbind(redSPP,vectorthresh)
  for (x in 1:S){
    if(length(A)>9 & sum(A)!=0){ #mayor a 9 porque Vane habia puesto un corte del 10%
      B <- A[-1,]
      A <- B[,-1]
      repeat {
        if (length(A) > 1){
          a <- vector("integer",0)
          for (l in 1:length(A)) {
            z <- vector("logical",0)
            for (k in 1:N) {z <- c(z, names(A)[l] == dnr[k])}
          if ((sum((A[-(length(A)+1),])[,l]) <= A[(length(A)+1),l]) & !any(z)){
            a <- c(a,l)}}
        if (length(a)>0){
          A <- A[-a,]
          A <- A[,-a]
          } else {
            # m<-A[-(length(A)+1),]
            break}}}
      m<-A[-(length(A)+1),]
      net[[x]] <-m
      }} #de la ext primaria
  Net[[i]] <- net
}#del umbral

#calculate secondary extinctions
net1 <- Net[[1]]
net_spp<- data.frame()
for (i in 1:length(net1)){
  count<-print(count(net1[[i]]))
  net_spp <- rbind(net_spp, count)
}
net_spp$pri_ext <- 1:nrow(net_spp)
net_spp$sec_ext <- (((net_spp[1,1]+1) - net_spp$pri_ext) - net_spp$n)

attach(net_spp)
plot(pri_ext, ((net_spp[1,1]-sec_ext)/net_spp[1,1]))

#save as needed
#net_spp1 <- net_spp
#net_spp2 <- net_spp
#net_spp3 <- top_n(net_spp, length(support_seqSPP), pri_ext)
#net_spp4 <- top_n(net_spp, length(support_seqSPP), pri_ext)
#net_spp5 <- top_n(net_spp, length(provider_seqSPP), pri_ext)

```

```{r}
#ES-inclusive subset

#identify ES
ES <- subset(ESnodes, ESnodes$vertextype > 30)
ES <- as.vector(ES[,1])
dnr2 <- c(ES,producers) 
#ES are placed at the end to decrease the likelihood they will be removed in a primary extinction. 
#not included in the actual dnr group because they need to be subject to "secondary extinctions"
#producer species are placed at the end as a failsafe. do not remove function in simulation does
#not always work

# create sequence vectors
sym_diff <- function(a,b) unique(c(setdiff(a,b), setdiff(b,a))) #custom right outer join function

#least and most connected
ESnet <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes) #determine degrees for connection
degree <- degree(ESnet, loops = TRUE)
ESnodes$degree <- degree
least_conn_seq <- ESnodes[order(ESnodes$degree),] #least connected
least_conn_seq <- as.vector(least_conn_seq[,1])
least_conn_seq <- sym_diff(dnr2,least_conn_seq) #place ES and producers at end
least_conn_seq <- c(least_conn_seq, dnr2)
most_conn_seq <- ESnodes[order(ESnodes$degree, decreasing = TRUE), ] #most connected
most_conn_seq <- as.vector(most_conn_seq[,1])
most_conn_seq <- sym_diff(dnr2, most_conn_seq) #place ES and producers at end
most_conn_seq <- c(most_conn_seq, dnr2)

#support species
all <- as.vector(ESnodes[,1])
provider_seq <- subset(ESlinks, ESlinks$edgetype > 0)
provider_seq <- as.vector(provider_seq[,1])
provider_seq <- unique(provider_seq)
support_seq <- sym_diff(provider_seq, all) #isolate supporting species
support_seq <- unique(support_seq)
ran_support_seq <- sample(support_seq, length(support_seq), replace = FALSE) #randomize
ran_support_seq <- c(ran_support_seq, provider_seq) #add non-supporting species to end of web
ran_support_seq <- sym_diff(dnr2, ran_support_seq) 
ran_support_seq <- c(ran_support_seq, dnr2) #place ES and producers at end
importance_support_seq <- as.vector(importance_seq[,2]) #load personalized pageranks
importance_support_seq <- c(importance_support_seq, ES)
importance_support_seq <- sym_diff(importance_support_seq, provider_seq) #sort to only support species
importance_support_seq <- c(importance_support_seq, provider_seq) #add non-supporting species to end of web
importance_support_seq <- sym_diff(dnr2, importance_support_seq)
importance_support_seq <- c(importance_support_seq, dnr2) #place ES and producers at end

#provider species
provider_seq <- subset(ESlinks, ESlinks$edgetype > 0) #isolate provider species
provider_seq <- as.vector(provider_seq[,1])
provider_seq <- unique(provider_seq)
ran_provider_seq <- sample(provider_seq, length(provider_seq), replace = FALSE) #randomize
ran_provider_seq <- c(ran_provider_seq, support_seq) #add non-provider species to web
ran_provider_seq <- sym_diff(dnr2, ran_provider_seq)
ran_provider_seq <- c(ran_provider_seq, dnr2) #place ES and producers at end

#order nodes according to seq
ESnodes1 <- ESnodes[match(least_conn_seq, ESnodes$Species), ]
ESnodes2 <- ESnodes[match(most_conn_seq, ESnodes$Species), ]
ESnodes3 <- ESnodes[match(importance_support_seq, ESnodes$Species), ]
ESnodes4 <- ESnodes[match(ran_support_seq, ESnodes$Species), ]
ESnodes5 <- ESnodes[match(ran_provider_seq, ESnodes$Species), ]

#create network objects for each sequence
ESnet1 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes1) #as graph
ESmat1 <- as_adjacency_matrix(ESnet1, sparse = FALSE, attr = NULL) #as matrix
ESnet1 <- as.data.frame(ESmat1) #as df
ESnet2 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes2) #as graph
ESmat2 <- as_adjacency_matrix(ESnet2, sparse = FALSE, attr = NULL) #as matrix
ESnet2 <- as.data.frame(ESmat2) #as df
ESnet3 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes3) #as graph
ESmat3 <- as_adjacency_matrix(ESnet3, sparse = FALSE, attr = NULL) #as matrix
ESnet3 <- as.data.frame(ESmat3) #as df
ESnet4 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes4) #as graph
ESmat4 <- as_adjacency_matrix(ESnet4, sparse = FALSE, attr = NULL) #as matrix
ESnet4 <- as.data.frame(ESmat4) #as df
ESnet5 <- graph.data.frame(ESlinks, directed = T, vertices = ESnodes5) #as graph
ESmat5 <- as_adjacency_matrix(ESnet5, sparse = FALSE, attr = NULL) #as matrix
ESnet5 <- as.data.frame(ESmat5) #as df

#prepare for extinction simulations
#rotate active network as needed
#redES <- ESnet1
redES <- ESnet2
#redES <- ESnet3
#redES <- ESnet4
#redES <- ESnet5

N <-length(dnr)
Net<-list()
S <- length(redES)

#threshold vector
for (i in 1:9){
  thresh<- i/10
  NumPrey <-rep(0,S)
  vectorthresh <- as.data.frame(NumPrey,row.names=names(redES))
  #thresh <- 1-thresh
  for (b in 1:S) {
    vectorthresh[b,1] <- sum(redES[,b])}
  vectorthresh <- (vectorthresh*thresh)
  vectorthresh <- as.vector(vectorthresh[,1])
  net<-list()
  A <- rbind(redES,vectorthresh)
  for (x in 1:S){
    if(length(A)>9 & sum(A)!=0){ #mayor a 9 porque Vane habia puesto un corte del 10%
      B <- A[-1,]
      A <- B[,-1]
      repeat {
        if (length(A) > 1){
          a <- vector("integer",0)
          for (l in 1:length(A)) {
            z <- vector("logical",0)
            for (k in 1:N) {z <- c(z, names(A)[l] == dnr[k])}
          if ((sum((A[-(length(A)+1),])[,l]) <= A[(length(A)+1),l]) & !any(z)){
            a <- c(a,l)}}
        if (length(a)>0){
          A <- A[-a,]
          A <- A[,-a]
          } else {
            # m<-A[-(length(A)+1),]
            break}}}
      m<-A[-(length(A)+1),]
      net[[x]] <-m
      }} #end primary extinction
  Net[[i]] <- net
}#end threshold vector

#data calculations
net1 <- Net[[1]] #can be set to any threshold; this is closest to Keyes
net_ES<- data.frame()
for (i in 1:length(net1)){
  species <- as.data.frame(net1[[i]])
  species <- names(species)
  species_diff <- intersect(ES,species)
  ES_lost <- (length(ES)-length(species_diff))
  net_ES <- rbind(net_ES, ES_lost)
}
net_ES$pri_ext <- 1:nrow(net_ES)

#rotate active network as needed
#net_ES1 <- net_ES
#net_ES2 <- net_ES
#net_ES3 <- top_n(net_ES, length(support_seqES), pri_ext)
#net_ES4 <- top_n(net_ES, length(support_seqES), pri_ext)
#net_ES5 <- top_n(net_ES, length(provider_seqES), pri_ext)


attach(net_ES)
plot(pri_ext, (8-X0L)/8)

```